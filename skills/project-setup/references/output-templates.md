# Output Templates Reference

This document provides exact templates for every file type generated by the project-setup skill. Use these templates in Phase 3 when generating configuration files.

---

## 1. Settings.json (Hooks)

The hooks configuration lives in `.claude/settings.json`. This file may already exist with permissions and other settings — always merge, never overwrite.

### Structure

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "SCRIPT_HERE"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "COMMAND_HERE"
          }
        ]
      }
    ],
    "Notification": [
      {
        "matcher": "stop",
        "hooks": [
          {
            "type": "command",
            "command": "COMMAND_HERE"
          }
        ]
      }
    ]
  }
}
```

### PostToolUse Formatter Hook Template

```json
{
  "matcher": "Write|Edit",
  "hooks": [
    {
      "type": "command",
      "command": "FORMATTER_COMMAND $CLAUDE_FILE_PATHS"
    }
  ]
}
```

Replace `FORMATTER_COMMAND` with the appropriate formatter for the project.

### PreToolUse Safety Guard Template

For blocking edits to sensitive files, the command should be a script that checks the file path and exits with code 2 to block:

**Unix/macOS:**
```json
{
  "matcher": "Write|Edit",
  "hooks": [
    {
      "type": "command",
      "command": "case \"$CLAUDE_FILE_PATHS\" in *.env|*.env.*|.env) echo 'BLOCKED: Do not edit .env files directly. Use .env.example instead.' && exit 2;; esac"
    }
  ]
}
```

**Windows (PowerShell):**
```json
{
  "matcher": "Write|Edit",
  "hooks": [
    {
      "type": "command",
      "command": "powershell -Command \"if ($env:CLAUDE_FILE_PATHS -match '\\.env') { Write-Output 'BLOCKED: Do not edit .env files directly. Use .env.example instead.'; exit 2 }\""
    }
  ]
}
```

### Lock File Guard Template

**Unix/macOS:**
```json
{
  "matcher": "Write|Edit",
  "hooks": [
    {
      "type": "command",
      "command": "case \"$CLAUDE_FILE_PATHS\" in *package-lock.json|*yarn.lock|*pnpm-lock.yaml|*Cargo.lock|*poetry.lock|*Gemfile.lock|*composer.lock) echo 'BLOCKED: Lock files should only be modified by the package manager.' && exit 2;; esac"
    }
  ]
}
```

**Windows (PowerShell):**
```json
{
  "matcher": "Write|Edit",
  "hooks": [
    {
      "type": "command",
      "command": "powershell -Command \"if ($env:CLAUDE_FILE_PATHS -match '(package-lock\\.json|yarn\\.lock|pnpm-lock\\.yaml|Cargo\\.lock|poetry\\.lock|Gemfile\\.lock|composer\\.lock)') { Write-Output 'BLOCKED: Lock files should only be modified by the package manager.'; exit 2 }\""
    }
  ]
}
```

### Build Artifact Guard Template

**Unix/macOS:**
```json
{
  "matcher": "Write|Edit",
  "hooks": [
    {
      "type": "command",
      "command": "case \"$CLAUDE_FILE_PATHS\" in dist/*|build/*|*.min.js|*.min.css|*.bundle.js) echo 'BLOCKED: Do not edit build artifacts or minified files — these are generated by the build process.' && exit 2;; esac"
    }
  ]
}
```

**Windows (PowerShell):**
```json
{
  "matcher": "Write|Edit",
  "hooks": [
    {
      "type": "command",
      "command": "powershell -Command \"if ($env:CLAUDE_FILE_PATHS -match '(^dist[\\\\/]|^build[\\\\/]|\\.min\\.js$|\\.min\\.css$|\\.bundle\\.js$)') { Write-Output 'BLOCKED: Do not edit build artifacts or minified files — these are generated by the build process.'; exit 2 }\""
    }
  ]
}
```

### Migration Guard Template

**Unix/macOS:**
```json
{
  "matcher": "Write|Edit",
  "hooks": [
    {
      "type": "command",
      "command": "case \"$CLAUDE_FILE_PATHS\" in migrations/*|alembic/versions/*|prisma/migrations/*) echo 'BLOCKED: Do not edit migration files directly — use the migration tool to generate new migrations.' && exit 2;; esac"
    }
  ]
}
```

**Windows (PowerShell):**
```json
{
  "matcher": "Write|Edit",
  "hooks": [
    {
      "type": "command",
      "command": "powershell -Command \"if ($env:CLAUDE_FILE_PATHS -match '(^migrations[\\\\/]|^alembic[\\\\/]versions[\\\\/]|^prisma[\\\\/]migrations[\\\\/])') { Write-Output 'BLOCKED: Do not edit migration files directly — use the migration tool to generate new migrations.'; exit 2 }\""
    }
  ]
}
```

### Merging Strategy

When `.claude/settings.json` already exists:
1. Read the existing file with the Read tool
2. Parse the JSON structure
3. Check for existing `hooks` key
4. For each event type (PreToolUse, PostToolUse, Notification):
   - If the event key doesn't exist, add it with the new hooks
   - If the event key exists, check each existing matcher
   - If a matcher already matches the same pattern, skip (don't duplicate)
   - If a new matcher is needed, append to the array
5. Preserve all other keys in the file (permissions, allow, deny, etc.)
6. Write the merged result

---

## 2. MCP Server Configuration (.claude/.mcp.json)

### Structure

```json
{
  "mcpServers": {
    "server-name": {
      "type": "stdio",
      "command": "npx",
      "args": ["-y", "package-name@latest"],
      "env": {}
    }
  }
}
```

### Server Templates

**Context7 (framework docs):**
```json
{
  "context7": {
    "type": "stdio",
    "command": "npx",
    "args": ["-y", "@upstash/context7-mcp@latest"],
    "env": {}
  }
}
```

**Playwright (browser testing):**
```json
{
  "playwright": {
    "type": "stdio",
    "command": "npx",
    "args": ["-y", "@anthropic-ai/mcp-server-playwright@latest"],
    "env": {}
  }
}
```

**GitHub:**
```json
{
  "github": {
    "type": "stdio",
    "command": "npx",
    "args": ["-y", "@anthropic-ai/mcp-server-github@latest"],
    "env": {
      "GITHUB_TOKEN": "YOUR_GITHUB_TOKEN_HERE"
    }
  }
}
```

**PostgreSQL:**
```json
{
  "postgres": {
    "type": "stdio",
    "command": "npx",
    "args": ["-y", "@anthropic-ai/mcp-server-postgres@latest", "CONNECTION_STRING_HERE"],
    "env": {}
  }
}
```

**Sentry:**
```json
{
  "sentry": {
    "type": "stdio",
    "command": "npx",
    "args": ["-y", "@anthropic-ai/mcp-server-sentry@latest"],
    "env": {
      "SENTRY_AUTH_TOKEN": "YOUR_SENTRY_TOKEN_HERE"
    }
  }
}
```

### Merging Strategy

When `.claude/.mcp.json` already exists:
1. Read the existing file
2. Parse the JSON
3. For each new server, check if a server with the same name exists
4. If it exists, skip it (don't overwrite existing server config)
5. If it doesn't exist, add it to the `mcpServers` object
6. Write the merged result

**Important:** For servers that need credentials (marked with `YOUR_*_HERE` placeholders), add a comment in the post-generation summary telling the user to fill in the actual values.

---

## 3. Skill SKILL.md Template

Each generated skill gets its own directory under `.claude/skills/` with a SKILL.md file.

### Template

```markdown
---
name: SKILL_NAME
description: SKILL_DESCRIPTION
invocation: user
user_invocation: /INVOCATION_NAME
---

# SKILL_TITLE

SKILL_INSTRUCTIONS

## Context

WHAT_THE_SKILL_NEEDS_TO_KNOW

## Steps

1. STEP_ONE
2. STEP_TWO
3. STEP_THREE

## Output Format

EXPECTED_OUTPUT_DESCRIPTION
```

### Example: gen-test Skill

```markdown
---
name: gen-test
description: Generate unit tests for a specified module or function
invocation: user
user_invocation: /gen-test
---

# Generate Tests

Generate comprehensive unit tests for the specified module or function. Follow the project's existing test patterns and conventions.

## Context

- Test framework: [DETECTED_FRAMEWORK]
- Test directory: [DETECTED_TEST_DIR]
- Test file naming: [DETECTED_PATTERN, e.g., "*.test.ts", "test_*.py"]

## Steps

1. Read the target module/function specified by the user
2. Identify the public API, edge cases, and error conditions
3. Read 1-2 existing test files to match the project's testing style
4. Generate tests covering:
   - Happy path for each public function/method
   - Edge cases (empty input, null, boundary values)
   - Error conditions (invalid input, thrown exceptions)
5. Write the test file to the appropriate test directory
6. Run the test suite to verify the new tests pass

## Output Format

Write the test file and report:
- Number of test cases generated
- Coverage areas (happy path, edge cases, errors)
- Any tests that need manual review
```

### Example: api-doc Skill

```markdown
---
name: api-doc
description: Generate or update API documentation from route definitions
invocation: user
user_invocation: /api-doc
---

# API Documentation Generator

Analyze API route definitions and generate comprehensive documentation.

## Steps

1. Scan the API routes directory for all endpoint definitions
2. For each endpoint, extract: method, path, parameters, request body, response type
3. Read any existing API documentation
4. Generate/update documentation in the project's preferred format
5. Include request/response examples where types are available

## Output Format

Generate documentation as Markdown with:
- Endpoint table of contents
- Detailed endpoint sections with method, path, description
- Request/response examples
- Authentication requirements where detected
```

---

## 4. Agent .md Template

Each generated agent gets a `.md` file in `.claude/agents/`.

### Template

```markdown
# AGENT_NAME

AGENT_DESCRIPTION

## Model

RECOMMENDED_MODEL

## Tools

ALLOWED_TOOL_LIST

## Instructions

DETAILED_INSTRUCTIONS_FOR_THE_AGENT

## Scope

WHAT_THE_AGENT_SHOULD_AND_SHOULD_NOT_DO
```

### Example: code-reviewer Agent

```markdown
# Code Reviewer

Review code changes for quality, patterns, potential bugs, and adherence to project conventions.

## Model

sonnet

## Tools

Read, Grep, Glob

## Instructions

When reviewing code:
1. Read the changed files and understand the context of the change
2. Check for common issues:
   - Logic errors and off-by-one mistakes
   - Missing error handling for operations that can fail
   - Resource leaks (unclosed connections, file handles)
   - Naming consistency with the rest of the codebase
   - Unnecessary complexity or over-engineering
3. Check for project-specific patterns:
   - Follow the established patterns in the codebase
   - Ensure imports follow the project convention
   - Verify error handling matches the project style
4. Report findings as a structured list with severity (critical, warning, suggestion)

## Scope

- DO: Review logic, patterns, naming, error handling, security basics
- DO NOT: Review formatting (hooks handle this), suggest major refactors, modify files
```

### Example: security-reviewer Agent

```markdown
# Security Reviewer

Review code changes for security vulnerabilities and sensitive data exposure.

## Model

sonnet

## Tools

Read, Grep, Glob

## Instructions

When reviewing code for security:
1. Check for OWASP Top 10 vulnerabilities:
   - Injection (SQL, command, XSS)
   - Broken authentication/authorization
   - Sensitive data exposure
   - Security misconfiguration
   - Insecure deserialization
2. Check for project-specific security concerns:
   - Authentication/authorization bypass
   - Missing input validation at system boundaries
   - Hardcoded secrets or credentials
   - Insecure direct object references
   - Missing rate limiting on sensitive endpoints
3. Report findings with severity (critical, high, medium, low)

## Scope

- DO: Flag security issues, check auth logic, verify input validation
- DO NOT: Review code quality (that's code-reviewer's job), modify files
```

---

## 5. File Ordering

When generating multiple files, follow this order to ensure directories exist before files are written into them:

1. `CLAUDE.md` (project root)
2. `.claude/settings.json` (create/merge)
3. `.claude/.mcp.json` (create/merge)
4. `.claude/skills/[name]/SKILL.md` (for each skill)
5. `.claude/agents/[name].md` (for each agent)
